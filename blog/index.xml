<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Blogs on Marko Kevac home </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://mkevac.github.io/blog/index.xml</link>
    <language>en-us</language>
    
    
    <updated>Thu, 19 Jun 2014 16:53:12 UTC</updated>
    
    <item>
      <title>Perf and stack traces</title>
      <link>http://mkevac.github.io/blog/perf_and_stack_traces</link>
      <pubDate>Thu, 19 Jun 2014 16:53:12 UTC</pubDate>
      
      <guid>http://mkevac.github.io/blog/perf_and_stack_traces</guid>
      <description>&lt;p&gt;I was wondering why perf record -g don&amp;rsquo;t show proper stack traces for my programs in production environment.
First I thought that kernel was too old, but after performing few experiments I have found out that it wasn&amp;rsquo;t the case.
Problem was that when you compile with optimizations (-O3), gcc automatically omits frame pointers.
And it is not easy to unwind stack traces without frame pointers. But gcc can do it somehow.
So I have continued digging and stumbled upon article where people bash one of the perf authors for not
being able to unwind stacks without frame pointers.&lt;/p&gt;

&lt;p&gt;If you read thoroughly you can find out that gcc uses DWARF debugging information for stack unwinding,
but it&amp;rsquo;s too slow for profilers.&lt;/p&gt;

&lt;p&gt;So I wanted to know how much slower would my programs be if I include frame pointers.
And seems that performance losses are
&lt;a href=&#34;http://dom.as/2009/07/26/on-binaries-and-fomit-frame-pointer/&#34;&gt;negligible&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I tested two MySQL builds, one built with ‘-O3 -g -fno-omit-frame-pointer’ and other with
-fomit-frame-pointer instead – and performance difference was negligible. It was around 1%
in sysbench tests, and slightly over 3% at tight-loop select
benchmark(100000000,(select asin(5+5)+sin(5+5))); on a 2-cpu Opteron box.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So I will try including frame pointers from now on. To include them, use -fno-omit-frame-pointers gcc parameter when building executable.&lt;/p&gt;

&lt;p&gt;If you are interested what frame pointers are and how they work, I would recommend reading answer to this stackoverflow question.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>perf and latest linux kernel</title>
      <link>http://mkevac.github.io/blog/perf_and_latest_linux_kernel</link>
      <pubDate>Fri, 02 May 2014 17:05:57 UTC</pubDate>
      
      <guid>http://mkevac.github.io/blog/perf_and_latest_linux_kernel</guid>
      <description>

&lt;p&gt;I have being playing today with perf on latest available kernel in Fedora (3.13). These are just some observations and thoughts.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;perf trace&lt;/h2&gt;

&lt;p&gt;This tool is similar to strace, but almost without overhead. Contrary to strace, you can use perf trace to watch syscalls system wide or system calls generated by processes owned by certain user.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;perf top&lt;/h2&gt;

&lt;p&gt;Function names are shown correctly and -g parameter is now available. It means that you can get call traces in a real time (without perf record).&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;perf timechart&lt;/h2&gt;

&lt;p&gt;This tool creates cool looking diagrams of a system workload.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://3.bp.blogspot.com/-8xsIoO22Hiw/U2Pa5R2yQSI/AAAAAAAAFls/1Let5ucfV2o/s1600/Screenshot+from+2014-05-02+21:50:12.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;perf sched&lt;/h2&gt;

&lt;p&gt;This tool shows you very verbose system scheduler statistics. Including latencies for a particular process.
You can see if your server wasn&amp;rsquo;t available because of scheduler.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know what for, but perf sched can replay previously recorded system load.
Maybe it is useful for scheduler development and optimization.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;perf mem&lt;/h2&gt;

&lt;p&gt;This tool collects memory requests. It can show you whether your memory request was served by CPU cashe or not for example.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://1.bp.blogspot.com/-HLz2t-vI4zg/U2PbxzF3_WI/AAAAAAAAFl4/Jwxq1ZMEVAc/s1600/Screenshot+from+2014-05-02+21:40:37.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;perf lock&lt;/h2&gt;

&lt;p&gt;This tool presumably allows you to collect information about various locks in your process and in the kernel,
but it&amp;rsquo;s not working on a last Fedora kernel because it lacks particular option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo perf lock record -p 12727
tracepoint lock:lock_acquire is not enabled. Are CONFIG_LOCKDEP and CONFIG_LOCK_STAT enabled?
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Who is calling?</title>
      <link>http://mkevac.github.io/blog/who_is_calling</link>
      <pubDate>Fri, 02 May 2014 17:00:29 UTC</pubDate>
      
      <guid>http://mkevac.github.io/blog/who_is_calling</guid>
      <description>&lt;p&gt;Sometimes your program uses a lot of system time. Let&amp;rsquo;s say 90%. You fire up your favorite profiling tool
and it tells you which system call it is. If you are experiences and maybe lucky, you can say straight
away which part of your program is to blame. But it&amp;rsquo;s not always so obvious.&lt;/p&gt;

&lt;p&gt;GDB comes to the rescue. You can use &amp;lsquo;catch syscall &lt;syscall&gt;&amp;rsquo; and it will break when particular
syscall is called. And then you can use &amp;lsquo;bt&amp;rsquo; to find where in your code this syscall is being called from.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb)&amp;gt; catch syscall futex

(gdb)&amp;gt; c
Continuing.
[Switching to Thread 0x7ffff3ffc700 (LWP 14893)]

Catchpoint 1 (call to syscall futex), 0x00007ffff76ce779 in __lll_unlock_wake_private () from /lib64/libc.so.6

(gdb)&amp;gt; bt
#0  0x00007ffff76ce779 in __lll_unlock_wake_private () from /lib64/libc.so.6
#1  0x00007ffff76060fc in _L_unlock_147 () from /lib64/libc.so.6
#2  0x00007ffff7606006 in random () from /lib64/libc.so.6
#3  0x000000000040154c in thread_worker (ctx=0x0) at memorytest.c:90
#4  0x00007ffff7992f33 in start_thread () from /lib64/libpthread.so.0
#5  0x00007ffff76c0ded in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;P.S. Don&amp;rsquo;t use random() in multi-threaded program. Use random_r().&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Uninterruptible sleep (D state)</title>
      <link>http://mkevac.github.io/blog/uninterruptible_sleep</link>
      <pubDate>Sat, 09 Feb 2013 17:10:58 UTC</pubDate>
      
      <guid>http://mkevac.github.io/blog/uninterruptible_sleep</guid>
      <description>

&lt;p&gt;Sometimes you will see processes on your linux box that are in D state as shown by ps, top, htop or similar.
D means uninterruptible sleep. As opposed to normal sleep, you can&amp;rsquo;t do anything with these processes (i.e. kill them).
Additional information could be found &lt;a href=&#34;http://lwn.net/Articles/288056/&#34;&gt;on LWN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Usually this means that process is stuck reading or writing something to disk or NFS and remote site does not answer. But not always. I&amp;rsquo;v stumbled upon processes that periodically jump into D state and back. These are processes under heavy network load. Strange&amp;hellip;&lt;/p&gt;

&lt;p&gt;While not been successful in finding out what is going on yet, I would like to share pointers how to dig deeper into these processes.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;Familiar tool ps can tell us in what function inside kernel our process is sleeping.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ps -eo ppid,pid,user,stat,pcpu,comm,wchan:32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding some bash magic will help us dealing with process that is constantly jumping between D, S and R states:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# for x in $(seq 10000); do ps -eo ppid,pid,user,stat,pcpu,comm,wchan:32 | grep D | grep laccess | awk &#39;{print $7}&#39; | grep -v &amp;quot;-&amp;quot;; done;
lock_sock_nested
lock_sock_nested
^C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so our process is sleeping in kernel function called lock_sock_nested.&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;sysrq&lt;/h2&gt;

&lt;p&gt;We can force linux kernel to dump backtraces for processes that are in D state. Information could be seen via dmesg utility or in /var/log/messages file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo w &amp;gt; /proc/sysrq-trigger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, with additional bash magic our command looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo w &amp;gt; /proc/sysrq-trigger; dmesg -c | less;

[688596.998782] SysRq : Show Blocked State
[688596.999054]   task                        PC stack   pid father
[688596.999101] laccessd      D 00000000ffffffff     0 26940  25632 0x00000000
[688596.999104]  ffff88090885fdd8 0000000000000086 ffff8800282d3700 ffff88125a5b2380
[688596.999107]  0000000000013700 ffff88090885ffd8 0000000000013700 ffff88090885ffd8
[688596.999109]  0000000000013700 0000000000013700 0000000000013700 0000000000013700
[688596.999111] Call Trace:
[688596.999113] Inexact backtrace:
[688596.999113] 
[688596.999122]  [&amp;lt;ffffffff810467de&amp;gt;] ? try_to_wake_up+0x1be/0x400
[688596.999128]  [&amp;lt;ffffffff8139cb13&amp;gt;] ? schedule_timeout+0x143/0x240
[688596.999133]  [&amp;lt;ffffffff81059a30&amp;gt;] ? process_timeout+0x0/0x10
[688596.999136]  [&amp;lt;ffffffff81135b23&amp;gt;] ? ep_poll+0x153/0x240
[688596.999139]  [&amp;lt;ffffffff81046a20&amp;gt;] ? default_wake_function+0x0/0x10
[688596.999141]  [&amp;lt;ffffffff81135ce4&amp;gt;] ? sys_epoll_wait+0xd4/0xe0
[688596.999146]  [&amp;lt;ffffffff81002f7b&amp;gt;] ? system_call_fastpath+0x16/0x1b
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Searching for a position of set bits in a variable</title>
      <link>http://mkevac.github.io/blog/searching_for_a_position_of_a_set_bits_in_variable</link>
      <pubDate>Sat, 30 Jun 2012 17:14:57 UTC</pubDate>
      
      <guid>http://mkevac.github.io/blog/searching_for_a_position_of_a_set_bits_in_variable</guid>
      <description>&lt;p&gt;In a deamon that I have created in Badoo I need to search for a positions of a bits in a 32 bit variable.
The simplest solution is to look at each bit, but there is a faster solution using
GCC &lt;a href=&#34;http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Other-Builtins.html&#34;&gt;built in function&lt;/a&gt; __builtin_ctzl:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Returns the number of trailing 0-bits in x, starting at the least significant bit position.
If x is 0, the result is undefined.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So I wrote test to compare speed of these two approaches:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/mkevac/3018264.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Here is the result of testing on my VirtualBox:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;marko@marko-virtual ~/badoo/temp $ gcc builtin_test.c -o test -O3 --std=gnu99
marko@marko-virtual ~/badoo/temp $ ./test
generating flags... 5 s
using cycle... 8 s
11929711 11926960 11926934 11925219 11928833 11923393 11923177
11924621 11924564 11928647 11921652 11924644 11926105 11929288
11929690 11924292 11923555 11922419 11925611 11924387 11928793
11926351 11928699 11927228 11922918 11921752 11927864 11926735
11927322 11923573 11932816 11930695
using builtin... 1 s
11929711 11926960 11926934 11925219 11928833 11923393 11923177
11924621 11924564 11928647 11921652 11924644 11926105 11929288
11929690 11924292 11923555 11922419 11925611 11924387 11928793
11926351 11928699 11927228 11922918 11921752 11927864 11926735
11927322 11923573 11932816 11930695
SAME
marko@marko-virtual ~/badoo/temp $ gcc builtin_test.c -o test -O0 -g3
--std=gnu99
marko@marko-virtual ~/badoo/temp $ gcc builtin_test.c -o test -O0 --std=gnu99
marko@marko-virtual ~/badoo/temp $ ./test
generating flags... 5 s
using cycle... 14 s
11929711 11926960 11926934 11925219 11928833 11923393 11923177
11924621 11924564 11928647 11921652 11924644 11926105 11929288
11929690 11924292 11923555 11922419 11925611 11924387 11928793
11926351 11928699 11927228 11922918 11921752 11927864 11926735
11927322 11923573 11932816 11930695
using builtin... 3 s
11929711 11926960 11926934 11925219 11928833 11923393 11923177
11924621 11924564 11928647 11921652 11924644 11926105 11929288
11929690 11924292 11923555 11922419 11925611 11924387 11928793
11926351 11928699 11927228 11922918 11921752 11927864 11926735
11927322 11923573 11932816 11930695
SAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While writing test, I have stumbled upon issue with bit shifting. It happened that if you right shift
by the size of a variable, you get not 0, but same number. So I have additional if statement
for case when I have to shift by 32.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>